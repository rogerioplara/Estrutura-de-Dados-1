Vetores
    - arranjo
    - array
    - matrizes de uma �nica linha

Em C s�o declarados igual a uma vari�vel, por�m o tamanho � definido na inst�ncia��o;
Primeiro elemento na posi��o 0;
�ltimo elemento est� na posi��o N-1;

Sintaxe:
<tipo><nome>[<tamanho>];
int A[10];

Declara��o com lista de inicializa��o:
<tipo><nome>[<tamanho>]={<v1>,<v2>,...,<vN>};
int B[3]={15,66,42};

Para acessar os elementos:
<nome_do_vetor>[<�ndice>];

---------------------------------------------------------------

Matrizes (bidimensional)
    - arranjo tabular de MxN valores, onde M � o n�mero de linhas e N � o n�mero de colunas;
    - os elementos s�o acess�veis tamb�m por �ndices:
        - i geralmente associado �s linhnas;
        - j geralmente associado �s colunas;
    - em uma matriz MxN:
        - �ndices variam de 0 a M-1 e de 0 a N-1;

Sintaxe:
<tipo><nome>[<dim1>][<dim2>]...[<dimN>];

Declara��o de Matriz bidimensional:
int A[3][3];

Para acessar os valores:
A[0][0];
A[2][2];
A[0][2];
A[1][0];

---------------------------------------------------------------

Estrutura de dados Heterog�neas (struct em C)
    - tamb�m conhecidas como registros, tipos de dados compostos, Structs(C);
    - agrupam informa��es de tipos de dados diferentes;
    - trata um grupo de valores como sendo uma �nica vari�vel, com v�rios campos distintos;
    - cria-se um novo tipo de dados;

Sintaxe:
struct <nome_do_registro>{
    <tipo> <nome_do_campo1>;
    <tipo> <nome_do_campo2>;
    <tipo> <nome_do_campo3>;
    ...
    <tipo> <nome_do_campoN>;
};

Como utilizar:
    - apenas definir n�o basta;
    - � preciso criar uma vari�vel do novo tipo criado;

Sintaxe de inst�ncia��o da vari�vel struct:
    struct <nome_do_registro> <nome_da_variavel>;
    struct produto p1;

Acesso � struct:
    - utiliza-se o nome da vari�vel est�tica seguida de um ponto (.);
    <nome_da_vari�vel>.<campo>;
    p1.preco;

Registros podem ser combinados com vetores:
    i. declara-se um novo registro;
    ii. cria-se um vetor de registros (assim como se cria uma vari�vel do tipo registro);

Exemplo: criar uma lista de produtos:
    - vetor de registros do tipo "produto";

---------------------------------------------------------------

# Ponteiros

## Vari�vel -> Endere�o de mem�ria;
    - conte�do armazenado, fisicamente, em uma posi��o de mem�ria;

## Cada tipo primitivo possui um tamanho e uma estrutura pr�prios, em mem�ria:
    - Char: 1 byte;
    - Int: 4 btyes;
    - Float: 4 bytes;
    - Double: 8 bytes;

# Aloca��o Din�mica de Mem�ria;

    Aloca��o est�tica:
        - Reserva espa�o de mem�ria em tempo de compila��o;
        - Pode ser mais r�pida durante a execu��o;
        - Pode desperdi�ar mem�ria;

    Aloca��o Din�mica:
        - Reserva espa�os de mem�ria em tempo de execu��o;
        - Pode ser mais lenta durante a execu��o;
        - Otimiza o uso da mem�ria;

        Uso de mem�ria alocada dinamicamente:
            - tentativa de aproveitar toda a ram dispon�vel;
            - cada m�quina disponibiliza um espa�o total de ram de tamanho pr�prio;
            - solu��o: alocar mem�ria, dinamicamente, conforme a necessidade;

        Aplica��es (exemplos):
            - processadores de texto (word);
            - bancos de dados;

PARA UTILIZAR A ALOCA��O DIN�MICA

Biblioteca stdlib.h

malloc();
    - aloca um bloco de bytes em mem�ria;
    - caso malloc() n�o consiga alocar um bloco:
        - Retorna NULL
        - caso contr�rio: retorna um ponteiro do tipo VOID contendo o endere�o inicial do bloco;
    - manipula-se o conte�do da vari�vel din�mica com o operador asterisco(*);

    sintaxe:
    *<vari�vel_ponteiro = <valor>;

    sintaxe:
    <ponteiro> = (<cast>*) malloc(<tam. em bytes>);

    cast: define o tipo do ponteiro -> int, float, struct, char...

    malloc retorna um endere�o do tipo VOID (n�o process�vel. por isso � necess�rio fazer o cast);

free();
    - libera o espa�o de mem�ria alocado a um ponteiro;

    sintaxe:
    free(<ponteiro>);

---------------------------------------------------------------

Listas, filas e pilhas

    Listas (computa��o)
    - Arranjo no qual a ordem dos elementos da lista coincide com sua posi��o f�sica (em mem�ria);
        - elementos adjacentes na lista ocupam posi��os cont�guas em mem�ria;
        - dois tipos espec�ficos: pilhas e filas;

    ## Pilhas (stack) LIFO - last in first out

    - Lista linear em que todos os acesso se d�o em uma �nica extremidade - o TOPO;
        ex: pilha de livros, pilha de pratos;
    - Os elementos s� podem ser inseridos no topo e s� podem ser retirados pelo topo;
    -> Novo elemento: Push
    -> Retirar elemento: Pop;

    Fun��es:
        Push(elemento); -> recebe como par�metro o elemento;
        Pop(); -> retorna o elemento que est� retirando;

    Aplica��es:
        - avan�ar e voltar em navegadores;
        - desfazer e refazer em editores;
        - recursividade;
        - chamada e execu��o de fun��es;

    Opera��es sobre pilhas
        - empilhar (push);
        - desempilhar (pop);

    ## Filas (queue) FIFO - first in first out

    - a inser��o de elementos � feita apenas ao FIM da fila;
    - a remo��o de elementod s� pode ser feita pela frente;

    FIFO
        Os dados s�o processados segundo a ordem de chegada;

    Opera��es com filas:
        Enfileirar(push_back);
        Desenfileirar(pop);

---------------------------------------------------------------

Listas Din�micas
    � muito mais simples interpretar listas, pilhas e filas quando implementadas em um vetor est�tico.
    - Vantagens da implementa��o est�tica:
        acesso direto a elementos;
        lista ordenada: busca bin�ria;

    - Desvantagens:
        nem sempre se sabe o �ndice do dado para acessar diretamente (necessita de busca);
        inser��o/remo��o ruins: "Arrastar os dados";
        O tamanho do vetor fica "engessado"

    Solu��o: permitir que os dados ocupem qualquer posi��o em mem�ria (posi��es n�o cont�guas);
    Gerencia-se a ordem dos elemntos atrav�s de refer�ncias que eles fazem entre si;

Inten��o: Evitar a defini��o de um n�mero m�ximo de elementos estaticamente
    - deixar que o n�mero m�ximo de elementos evolua dinamicamente em tempo de execu��o;

    A orde (l�gica) dos elementos da lista (n�s) n�o, necessariamente, deve coincidir com sua posi��o em mem�ria.

    LISTA LIGADA OU LISTA ENCADEADA
        - Utiliza a estrutura n� (regustro-struct)

        exemplo:
        struct NO{
            int dado;
            struct NO* prox;
        };

    Para desenvolver listas din�micas em linguagem C:
        - Fun��es de aloca��o de mem�ria;
        - malloc(), sizeof() e free();

    Estrutura n� (registro - struct)
        Dados: definidos pela aplica��o (chaves/valor);
        Refer�ncia para o pr�ximo elemento da lista;
            Ponteiro do tipo N�;

    O come�o da lista � demarcado por um ponteiro (sentinela) chamado 'inicio';

    Ponteiros que armazenam o valor "NULL"
        - tem o significado de "n�o apontar para elemento algum";

    Outros tipos:
        Lista duplamente encadeada;
        Lista circular;

INSER��O DE DADOS (lista):
    N�o h� regras: pode-se inserir em qualquer posi��o;

    CUIDADO: dependendo da posi��o da inser��o, podem haver casos espec�ficos:
        lista vazia; inicio da lista; meio da lista; fim da lista;

    Primeiro passo: alocar um novo n� (malloc);
    Segundo passo: percorer a lista (ponteiro);
    Terceiro passo: atualizar os ponteiros;

REMO��O DE DADOS (lista):
    A exclus�o de elementos de uma lista encadeada � semelhante a inser��o;
    O algoritmo deve prever alguns casos espec�ficos:
        - remo��o do primeiro elemento;
        - exclus�o de um elemento qualquer;

    Primeiro passo: percorrer a lista;
    Segundo passo: encontrar a posi��o de remo��o;
    Terceiro passo: atualizar os ponteiros;
    Quarto passo: liberar mem�ria;

IMPRESS�O DE DADOS (lista);

    para struct ponteiro utilizar o operador ->

    void imprimir(struct NO* ptr){
        system("cls");
        while(ptr! = NULL){
            printf("%d", ptr->dado);
            ptr = ptr->prox;
        }
    }

-------------------------------------------------------------

Pilhas din�micas

    Estrutura N�
        typedef struct NO{
            int dado;
            struct NO* prox;
        }NO;

    Estrutura Pilhas
        typedef struct PILHA{
            NO* topo;
        }PILHA;

    Vari�vel do tipo PILHA
        PILHA *p;

    Fun��o Empilha() ou Push()

    void empilha(){
        NO* ptr = (NO *) malloc(sizeof(NO));
        ptr->dado = rand()%100;
        ptr->prox = p->topo;
        p->topo = ptr;
    }

    Fun��o Desempilha() ou Pop()

    int desempilha(){
        NO* ptr = p->;
        int dado;
        if(ptr != NULL){
            p->topo = ptr->prox;
            ptr->prox = NULL;
            dado = ptr->dado;
            free(ptr);
            return dado;
        }
    }

-----------------------------------------------------

Fila Dinâmica

    - implementação
        


